{
  "name": "Analysis",
  "nodes": [
    {
      "parameters": {
        "chatId": "6340620540",
        "text": "={{ \n(() => {\n  const j = $json ?? {};\n  const pick = (...v) => v.find(x => x !== undefined && x !== null && String(x).trim() !== \"\");\n  const yesno = (b) => (b ? \"S√≠\" : \"No\");\n\n  // Evento (normalizado)\n  const eventId = pick(j.event_id, j.analysis?.key_facts?.event_id, \"\");\n  const ts = pick(j.event_timestamp, j.analysis?.key_facts?.event_timestamp, \"\");\n  const ruleId = pick(j.rule_id, j.analysis?.key_facts?.rule_id, \"\");\n  const ruleLevel = pick(j.rule_level, j.analysis?.key_facts?.rule_level, \"\");\n  const host = pick(j.agent_name, j.analysis?.key_facts?.agent_name, j.raw?.agent?.name, \"\");\n  const srcIp = pick(j.src_ip, j.analysis?.key_facts?.src_ip, j.raw?.data?.srcip, \"\");\n  const dstIp = pick(j.dst_ip, j.analysis?.key_facts?.dst_ip, j.raw?.data?.dstip, \"\");\n\n  // Triage\n  const triageSev = pick(j.triage_severity, j.analysis?.key_facts?.triage_severity, \"\");\n  const triagePri = pick(j.triage_priority, j.analysis?.key_facts?.triage_priority, \"\");\n  const triageRisk = pick(j.triage_risk, j.analysis?.key_facts?.triage_risk, \"\");\n\n  // Routing\n  const sendToAnalysis = j.routing?.send_to_analysis;\n  const routeReason = pick(j.routing?.reason, \"\");\n\n  // Analisis-MCP (si existe)\n  const cls = pick(j.analysis?.classification, \"\");\n  const aiRisk = pick(j.analysis?.ai_risk_level_1_15, \"\");\n  const aiPri = pick(j.analysis?.ai_priority_band, \"\");\n  const hitl = pick(j.analysis?.hitl_required, j.triage?.hitlRequired, false);\n  const summary = pick(j.analysis?.summary_es, \"\");\n\n  // MITRE compare\n  const wazuhTac = (j.mitre?.wazuh?.tactics ?? []).join(\", \");\n  const wazuhTec = (j.mitre?.wazuh?.techniques ?? []).join(\", \");\n  const aiTac = pick(j.mitre?.ai_inferred?.tactic, j.mitre_tactic, \"\");\n  const aiTec = pick(j.mitre?.ai_inferred?.technique, j.mitre_technique, \"\");\n  const mitreStatus = pick(j.mitre?.comparison?.status, \"\");\n  const mitreNotes = pick(j.mitre?.comparison?.notes, \"\");\n\n  // Response plan (si existe)\n  const rp = j.response_plan ?? null;\n  const opt = pick(rp?.selected_option, \"\");\n  const playbook = pick(rp?.playbook, \"\");\n  const approval = pick(rp?.requires_approval, false);\n  const actions = Array.isArray(rp?.actions) ? rp.actions : [];\n  const actionLines = actions.slice(0, 5).map(a => {\n    const t = pick(a?.type, \"NA\");\n    const ip = pick(a?.params?.ip, \"\");\n    const msg = pick(a?.params?.message, \"\");\n    return `- ${t}${ip ? ` ip=${ip}` : \"\"}${msg ? ` msg=\"${msg.slice(0,80)}\"` : \"\"}`;\n  }).join(\"\\n\");\n\n  const lines = [];\n  lines.push(\"üö® CEC Alert\");\n  if (eventId) lines.push(`event_id: ${eventId}`);\n  if (ts) lines.push(`ts: ${ts}`);\n  lines.push(`rule: ${ruleId || \"NA\"} (lvl ${ruleLevel || \"NA\"})`);\n  if (host) lines.push(`host: ${host}`);\n  if (srcIp || dstIp) lines.push(`net: ${srcIp || \"NA\"} ‚Üí ${dstIp || \"NA\"}`);\n\n  if (triageSev !== \"\" || triagePri || triageRisk !== \"\") {\n    lines.push(`triage: sev=${triageSev !== \"\" ? triageSev : \"NA\"} pri=${triagePri || \"NA\"} risk=${triageRisk !== \"\" ? triageRisk : \"NA\"}`);\n  }\n\n  if (cls || aiRisk !== \"\" || aiPri) {\n    lines.push(`analysis: cls=${cls || \"NA\"} ai_risk=${aiRisk !== \"\" ? aiRisk : \"NA\"} ai_pri=${aiPri || \"NA\"} HITL=${yesno(!!hitl)}`);\n  }\n\n  if (sendToAnalysis !== undefined) {\n    lines.push(`routing: send_to_analysis=${yesno(!!sendToAnalysis)}${routeReason ? ` (${routeReason})` : \"\"}`);\n  }\n\n  if (wazuhTac || wazuhTec || aiTac || aiTec) {\n    lines.push(\"MITRE:\");\n    lines.push(`- wazuh: ${[wazuhTac && (\"tac=\" + wazuhTac), wazuhTec && (\"tec=\" + wazuhTec)].filter(Boolean).join(\" | \") || \"NA\"}`);\n    lines.push(`- ai: ${[aiTac && (\"tac=\" + aiTac), aiTec && (\"tec=\" + aiTec)].filter(Boolean).join(\" | \") || \"NA\"}`);\n    if (mitreStatus) lines.push(`- compare: ${mitreStatus}${mitreNotes ? ` (${mitreNotes})` : \"\"}`);\n  }\n\n  if (rp) {\n    lines.push(\"üõ°Ô∏è Response plan:\");\n    lines.push(`option: ${opt || \"NA\"} | playbook: ${playbook || \"NA\"} | approval: ${yesno(!!approval)}`);\n    if (actionLines) lines.push(`actions:\\n${actionLines}`);\n    const msgHitl = pick(rp?.message_for_hitl, \"\");\n    if (msgHitl) lines.push(`HITL msg: ${msgHitl}`);\n  }\n\n  if (summary) {\n    lines.push(\"üßæ Resumen:\");\n    lines.push(summary);\n  }\n\n  return lines.join(\"\\n\").replaceAll(\"\\\\\", \"\").trim();\n})()\n}}\n",
        "additionalFields": {
          "appendAttribution": true
        }
      },
      "id": "7fd44f36-6a62-44bd-8f67-93076eda61e4",
      "name": "SOC Team",
      "type": "n8n-nodes-base.telegram",
      "position": [
        832,
        288
      ],
      "webhookId": "eef1fd94-eb2f-4f0e-a651-90731c34cf7c",
      "typeVersion": 1.2,
      "credentials": {
        "telegramApi": {
          "id": "2SmrbhySGPb1qAlr",
          "name": "Telegram account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO dbo.fr_metrics (\n  campaign_id,\n  scenario_id,\n  model_version,\n  window_start,\n  window_end,\n  event_id,\n  ts_analysis_start,\n  ts_analysis_end,\n  label_predicha,\n  severidad_predicha,\n  score_confianza,\n  mitre_technique,\n  mitre_tactic,\n  metric_scope,\n  created_at\n)\nVALUES (\n  {{ $json.campaign_id }},\n  {{ $json.scenario_id }},\n  'gpt-3.5-turbo',\n  '{{ $json.event_timestamp }}',   -- ventana = 1 evento\n  '{{ $json.event_timestamp }}',\n  {{ $json.event_id }},\n  '{{ $json.ts_analysis_start }}',\n  '{{ $json.ts_analysis_end }}',\n  '{{ $json.label_predicha || '' }}',\n  '{{ $json.severidad_predicha || '' }}',\n  {{ $json.score_confianza ?? 0 }},\n  '{{ $json.mitre_technique || '' }}',\n  '{{ $json.mitre_tactic || '' }}',\n  'event',\n  SYSUTCDATETIME()\n);\n"
      },
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1.1,
      "position": [
        672,
        592
      ],
      "id": "bc7b0499-2844-4c62-9077-fa56088151b6",
      "name": "INSERT fr_metrics(event)",
      "alwaysOutputData": true,
      "credentials": {
        "microsoftSql": {
          "id": "59sSXaGtmRRjhh5e",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are the SOC Analysis MCP agent.\n\nINPUT:\nYou receive ONE event as JSON from n8n. It is already normalized and may include:\n- event_id, campaign_id, scenario_id, wazuh_alert_id, event_timestamp\n- src_ip, dst_ip, src_port, dst_port, agent_name\n- rule_id, rule_level\n- triage_severity (0‚Äì15), triage_priority (Low|Medium|High|Critical), triage_risk (1‚Äì5), triage.hitlRequired\n- raw: the original Wazuh alert (may contain raw.rule.description, raw.rule.groups, raw.rule.mitre.tactic/technique, raw.data.*)\n\nTASK:\nReturn ONLY valid JSON (no markdown, no extra text) with EXACTLY these top-level keys:\n\"analysis\", \"mitre\", \"response_options\",\n\"label_predicha\", \"severidad_predicha\", \"score_confianza\",\n\"mitre_technique\", \"mitre_tactic\",\n\"ts_analysis_start\", \"ts_analysis_end\"\n\nHARD RULES (NO HALLUCINATIONS):\n- Do NOT invent or change any IPs, timestamps, hostnames, rule IDs, rule levels.\n- Do NOT claim you checked external reputation sources (VT/AbuseIPDB/OTX/etc.). If not present in input, say \"Not available\".\n- MITRE IDs: only output a technique ID if you are confident it follows the \"T####\" pattern AND it matches the observed behavior; otherwise leave empty string.\n- If raw.rule.mitre.* is missing, treat Wazuh MITRE as \"not_available\".\n\nOUTPUT JSON SHAPE:\n{\n  \"analysis\": {\n    \"classification\": \"benign|suspicious|malicious\",\n    \"confidence\": 0.0,\n    \"ai_risk_level_1_15\": 0,\n    \"ai_priority_band\": \"Low|Medium|High|Critical\",\n    \"hitl_required\": false,\n    \"summary_es\": \"\",\n    \"key_facts\": {\n      \"event_id\": \"\",\n      \"event_timestamp\": \"\",\n      \"rule_id\": \"\",\n      \"rule_level\": 0,\n      \"triage_severity\": 0,\n      \"triage_priority\": \"\",\n      \"triage_risk\": 0,\n      \"src_ip\": \"\",\n      \"dst_ip\": \"\",\n      \"agent_name\": \"\"\n    },\n    \"discrepancy_notes\": {\n      \"wazuh_vs_triage\": \"\",\n      \"wazuh_vs_ai\": \"\"\n    },\n    \"recommended_next_checks\": []\n  },\n  \"mitre\": {\n    \"wazuh\": {\n      \"tactics\": [],\n      \"techniques\": []\n    },\n    \"ai_inferred\": {\n      \"tactic\": \"\",\n      \"technique\": \"\"\n    },\n    \"comparison\": {\n      \"status\": \"match|partial|mismatch|not_available\",\n      \"notes\": \"\"\n    }\n  },\n  \"response_options\": {\n    \"recommended_response_intent\": \"notify_only|block_ip|isolate_host|collect_artifacts\",\n    \"playbook_candidates\": [\n      {\n        \"playbook\": \"PB_NOTIFY_ONLY|PB_BLOCK_IP|PB_COLLECT_ARTIFACTS|PB_ISOLATE_HOST\",\n        \"why\": \"\",\n        \"actions_suggested\": [\n          { \"type\": \"notify|block_ip|isolate_host|collect_artifacts\", \"params\": {} }\n        ]\n      }\n    ]\n  },\n  \"label_predicha\": \"malicious|benign\",\n  \"severidad_predicha\": \"baja|media|alta\",\n  \"score_confianza\": 0.0,\n  \"mitre_technique\": \"\",\n  \"mitre_tactic\": \"\",\n  \"ts_analysis_start\": \"\",\n  \"ts_analysis_end\": \"\"\n}\n\nFIELD FILLING GUIDANCE:\n1) key_facts:\n- Copy from normalized fields when present; otherwise use raw.* fallbacks.\n- If a value is missing, use \"\" for strings, 0 for numbers.\n\n2) Wazuh MITRE extraction:\n- tactics = raw.rule.mitre.tactic (array) if present else []\n- techniques = raw.rule.mitre.technique (array) if present else []\n\n3) AI MITRE inference (independent):\n- Infer from observed behavior in raw.rule.description/raw.rule.groups/raw.data.*.\n- If unclear, set tactic/technique to \"\".\n\n4) MITRE comparison:\n- status:\n  - \"not_available\" if Wazuh tactics/techniques are empty AND AI tactic/technique empty.\n  - \"match\" if AI technique matches any Wazuh technique OR AI tactic matches any Wazuh tactic.\n  - \"partial\" if only tactic matches but technique differs/empty.\n  - \"mismatch\" if both have values and neither tactic nor technique overlap.\n- notes: short Spanish note explaining why.\n\n5) classification & severity:\n- classification:\n  - \"benign\" if triage_severity < 4 AND rule_level < 8 AND no clear malicious indicators.\n  - \"suspicious\" if triage_severity >= 4 OR rule_level >= 8 but evidence is incomplete.\n  - \"malicious\" only if strong indicators exist in the event content (e.g., clear brute force pattern, confirmed exploit behavior, etc.).\n- ai_risk_level_1_15:\n  Start from triage_severity (0‚Äì15) but you may adjust by ¬±2 based on rule_level and evidence clarity. Keep 0‚Äì15.\n- ai_priority_band:\n  0‚Äì3 Low, 4‚Äì7 Medium, 8‚Äì11 High, 12‚Äì15 Critical.\n- hitl_required:\n  true if classification != \"benign\" OR ai_risk_level_1_15 >= 8 OR triage.hitlRequired == true.\n\n6) discrepancy_notes:\n- wazuh_vs_triage: explain difference between rule_level and triage_severity/triage_risk.\n- wazuh_vs_ai: explain if your ai_risk differs from rule_level.\n\n7) response_options:\n- Provide 2‚Äì3 playbook_candidates ordered by best fit.\n- recommended_response_intent should align with the top candidate.\n- actions_suggested must be safe and generic (no execution), e.g. notify, block_ip (only if src_ip exists), collect_artifacts, isolate_host.\n\n8) Metrics export fields (for DB insert):\n- label_predicha:\n  \"malicious\" if classification == \"malicious\" else \"benign\"\n- severidad_predicha:\n  \"alta\" if ai_risk_level_1_15 >= 12\n  \"media\" if ai_risk_level_1_15 between 8 and 11\n  \"baja\" otherwise\n- score_confianza:\n  use analysis.confidence (0..1)\n- mitre_technique / mitre_tactic:\n  use ai_inferred values (or \"\" if unknown)\n- ts_analysis_start and ts_analysis_end:\n  set both to current UTC time in ISO8601 if you cannot access system time, set them equal to event_timestamp (copy exact string).\n\nsummary_es:\n1‚Äì2 short Spanish sentences. Mention rule_id/rule_level and triage values; include IP/host only if present. Do not invent.\n\nReturn JSON only.\n",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        144,
        592
      ],
      "id": "c5d92a89-1b27-4d1b-9b2a-d33aa4ab534e",
      "name": "Analisis-MCP",
      "disabled": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-3.5-turbo",
          "mode": "list",
          "cachedResultName": "gpt-3.5-turbo"
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        112,
        784
      ],
      "id": "b47a6cbb-dd06-4c34-8d0b-eadaf58fc3ea",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "yt3NGZbVrbZuYATf",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "7a24796d-4cd9-42c8-9438-648de5ea022a",
              "leftValue": "={{ $json.routing.send_to_analysis }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        160,
        272
      ],
      "id": "37fbfac0-cc20-418c-a882-63180ad46056",
      "name": "If route_to_analysis",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// ts_analysis_start\nconst nowIso = new Date().toISOString();\n\nreturn $input.all().map(item => {\n  const j = item.json ?? {};\n  return {\n    json: {\n      ...j,\n      ts_analysis_start: j.ts_analysis_start || nowIso\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -32,
        592
      ],
      "id": "bb3c7375-6ebb-470d-93ca-2b41d66d95ea",
      "name": "ts_analysis_start"
    },
    {
      "parameters": {
        "jsCode": "// ts_analysis_end + tta (MTTA/TTA) + \"evento completo\" (evento original + an√°lisis)\nconst nowIso = new Date().toISOString();\n\nconst parseMs = (s) => {\n  const t = Date.parse(s);\n  return Number.isFinite(t) ? t : null;\n};\n\n// 1) Base = evento original (antes del LLM)\n//    Esto preserva campaign_id/scenario_id/event_id/event_timestamp/src_ip/etc.\nconst base = $node[\"ts_analysis_start\"]?.json ?? {};\n\n// 2) Overlay = salida del agente (analysis/mitre/response_options + m√©tricas)\n//    $json aqu√≠ es lo que viene desde \"Analisis-MCP\"\nconst overlay = $json ?? {};\n\n// 3) ts_ingest: intenta del nodo \"Set ts_ingest\" si existe, sino del base, sino vac√≠o\nconst tsIngest = base.ts_ingest || \"\";\n\n\n// 4) Calcula TTA en segundos\nconst ingestMs = parseMs(tsIngest);\nconst endMs = parseMs(nowIso);\nconst ttaSec = (ingestMs && endMs) ? Math.round((endMs - ingestMs) / 1000) : 0;\n\n// 5) ts_analysis_start: prioridad overlay > base > nowIso\nconst tsStart =\n  overlay.ts_analysis_start ||\n  base.ts_analysis_start ||\n  nowIso;\n\n// 6) Resultado final: evento completo + an√°lisis + tiempos\nreturn [{\n  json: {\n    ...base,\n    ...overlay,\n    ts_analysis_start: tsStart,\n    ts_analysis_end: nowIso,\n    tta_sec: overlay.tta_sec ?? base.tta_sec ?? ttaSec,\n  }\n}];\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        592
      ],
      "id": "49c8142e-5d9b-44fb-a68f-4c94fd7462ad",
      "name": "ts_analysis_end+tta"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -48,
        288
      ],
      "id": "ee96d0ac-2660-4210-8ce6-204ff9454710",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "jsCode": "// Devuelve el analizado si existe; si no, devuelve el evento original de entrada\nconst analyzed = $node[\"ts_analysis_end+tta\"]?.json;\n\nif (analyzed && Object.keys(analyzed).length) {\n  return [{ json: analyzed }];\n}\n\n// fallback: el evento original que entr√≥ al workflow\nconst incoming = $items(\"When Executed by Another Workflow\");\nreturn incoming.length ? incoming.map(i => ({ json: i.json })) : [{ json: $json }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1024,
        496
      ],
      "id": "ba9d5a68-fcfc-43f3-a57f-8e7be6c731b8",
      "name": "Return final event"
    },
    {
      "parameters": {
        "jsCode": "// Si no se analiz√≥, devuelve el evento tal cual lleg√≥\nreturn $input.all();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        608,
        400
      ],
      "id": "e0f95fed-920b-4146-b9b0-a76721533cdb",
      "name": "Return Passthrough"
    }
  ],
  "pinData": {},
  "connections": {
    "Analisis-MCP": {
      "main": [
        [
          {
            "node": "ts_analysis_end+tta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Analisis-MCP",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "If route_to_analysis": {
      "main": [
        [
          {
            "node": "ts_analysis_start",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Return Passthrough",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ts_analysis_start",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ts_analysis_start": {
      "main": [
        [
          {
            "node": "Analisis-MCP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ts_analysis_end+tta": {
      "main": [
        [
          {
            "node": "INSERT fr_metrics(event)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "If route_to_analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "INSERT fr_metrics(event)": {
      "main": [
        [
          {
            "node": "SOC Team",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Return final event": {
      "main": [
        []
      ]
    },
    "Return Passthrough": {
      "main": [
        [
          {
            "node": "SOC Team",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SOC Team": {
      "main": [
        [
          {
            "node": "Return final event",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Return final event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "f30cd9ef-b572-4296-95b9-e031c10e9e4f",
  "meta": {
    "instanceId": "5f4321b383184a4332b5d1e5cb6e70ea61441780fd28eb1fe8c95676a3e6f306"
  },
  "id": "RbwZ2h03ngEjTubg",
  "tags": []
}