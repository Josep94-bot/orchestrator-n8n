{
  "name": "tool: Explain workflow",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// tool_explain_workflow - robust lookup + alias + fuzzy matching (alineado al Router actual)\n// Accepts: $json.input | $json.workflow_name | $json.query | $json.chatInput\n// Returns: { ok, received, matched, explanation, available, suggestions, output }\n\nconst raw =\n  ($json.input ??\n   $json.workflow_name ??\n   $json.query ??\n   $json.chatInput ??\n   $json.message ??\n   '')\n  .toString()\n  .trim();\n\n// --- 1) Normalize input text (remove common Spanish/English wrappers) ---\nfunction normalizeText(s) {\n  return (s || '')\n    .toLowerCase()\n    .replace(/[\\u00E0-\\u00FC]/g, (c) => ({\n      'á':'a','é':'e','í':'i','ó':'o','ú':'u','ñ':'n',\n      'à':'a','è':'e','ì':'i','ò':'o','ù':'u',\n      'ä':'a','ë':'e','ï':'i','ö':'o','ü':'u'\n    }[c] ?? c))\n    .replace(/[^\\w\\s/-]/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\nfunction extractCandidateName(s) {\n  const t = normalizeText(s);\n  const patterns = [\n    /^(?:explica|explícame|explicame|explain)\\s+(?:el|la)?\\s*(?:flujo\\s+de\\s+trabajo|workflow|flujo)\\s*(?:de)?\\s*(.+)$/i,\n    /^(?:que\\s+hace|qué\\s+hace)\\s+(.+)$/i,\n    /^(?:describe)\\s+(.+)$/i\n  ];\n\n  for (const re of patterns) {\n    const m = t.match(re);\n    if (m && m[1]) return m[1].trim();\n  }\n  return t;\n}\n\nconst candidate = extractCandidateName(raw);\n\n// --- 2) Knowledge base (ALINEADO): Monitoring → Analysis → Response → ResponseExecute (+ herramientas reales) ---\nconst DB = {\n  Monitoring: {\n    canonical: 'Monitoring',\n    purpose: 'Recibe/normaliza alertas (Wazuh/telemetría), dedupe básico, triage inicial y persistencia del evento.',\n    inputs: ['alerta cruda (json/text)', 'timestamp fuente', 'agent/host', 'rule.*', 'data.srcip/dstip (si existe)'],\n    // ✅ actualizado: se elimina routing_send_to_analysis (el routing lo decide el Router/Agent)\n    outputs: ['cec_event normalizado', 'event_id', 'ts_ingest'],\n    // ✅ actualizado: sin \"Router a Analysis\" como output/nodo propio\n    nodes: ['Webhook/Trigger', 'Normalización CEC', 'INSERT dbo.cec_events'],\n    writes: ['dbo.cec_events (INSERT)'],\n    common_failures: ['IPs vienen en campos no estándar (data.*)', 'JSON inválido/escapado', 'duplicados por event_id', 'rule_id tipo texto vs int'],\n    aliases: [\n      'monitoring', 'monitor', 'tool_monitor_event', 'tool_monitor_events', 'monitoring.json',\n      'tool_monitor_event.json', 'tool_monitor_events.json'\n    ]\n  },\n\n  Analysis: {\n    canonical: 'Analysis',\n    purpose: 'Interpreta el evento y produce clasificación/riesgo/prioridad/MITRE + timestamps de análisis.',\n    inputs: ['event_id', 'evento normalizado', 'contexto mínimo (rule/agent/src/dst)'],\n    outputs: ['classification', 'ai_risk_level_1_15', 'ai_priority_band', 'mitre_*', 'ts_analysis_start/end'],\n    nodes: ['LLM', 'Parser/salida JSON', 'INSERT dbo.analysis_results'],\n    writes: ['dbo.analysis_results (INSERT versionado)'],\n    common_failures: ['Salida no es JSON válido', 'campos faltantes', 'types (int vs string)', 'no se setean timestamps'],\n    aliases: ['analysis', 'analisis', 'analyze', 'tool_analyze_event', 'analysis.json', 'tool_analyze_event.json']\n  },\n\n  // ✅ actualizado: ResponsePlan -> Response (mantener alias viejo)\n  Response: {\n    canonical: 'Response',\n    purpose: 'Selecciona playbook/opción y decide si requiere aprobación (HITL).',\n    inputs: ['analysis_results', 'triage_*', 'políticas de respuesta'],\n    outputs: ['playbook', 'selected_option', 'requires_approval'],\n    nodes: ['Reglas + LLM (opcional)', 'UPSERT dbo.response_plan'],\n    writes: ['dbo.response_plan (UPSERT)'],\n    common_failures: ['requires_approval no boolean', 'selected_option fuera de catálogo', 'plan inconsistente con playbook'],\n    aliases: [\n      // legacy\n      'responseplan', 'response plan', 'response_plan', 'responseplan.json', 'responseplan',\n      'responseplan ', 'response plan ',\n      'ResponsePlan', 'ResponsePlan.json', 'tool_plan_response', 'tool_plan_response.json',\n      // canonical\n      'response', 'Response.json'\n    ]\n  },\n\n  HITL: {\n    canonical: 'HITL',\n    purpose: 'Espera decisión humana (Aprobar/Denegar) y mide tiempos HITL.',\n    inputs: ['requires_approval=true', 'mensaje a Telegram/Chat', 'contexto'],\n    outputs: ['decision', 'ts_hitl_start/end', 'hitl_wait_seconds'],\n    nodes: ['sendAndWait', 'UPSERT dbo.hitl_decisions'],\n    writes: ['dbo.hitl_decisions (UPSERT)'],\n    common_failures: ['timeout sin setear hitl_timeout', 'decisión no normalizada', 'se pierde contexto entre wait y retorno'],\n    aliases: ['hitl', 'sendandwait', 'send and wait', 'approval', 'aprobacion', 'aprobación']\n  },\n\n  ResponseExecute: {\n    canonical: 'ResponseExecute',\n    purpose: 'Ejecuta acción (firewall/notify/etc), registra evidencia por intento y consolida métricas (fr_metrics) por event_id.',\n    inputs: ['playbook', 'selected_option', 'decision (si aplica)', 'target (ip/host)', 'event_id'],\n    outputs: ['status', 'evidencia', 'attempt_no', 'ts_response_start/end', 'fr_metrics (si aplica)'],\n    nodes: ['HTTP/SSH/Artifacts', 'INSERT dbo.response_execution', 'UPSERT dbo.fr_metrics (por event_id)'],\n    writes: ['dbo.response_execution (INSERT por intento)', 'dbo.fr_metrics (UPSERT por event_id)'],\n    common_failures: ['Body JSON inválido en HTTP Request', 'credenciales/endpoint', 'no setear attempt_no', 'ts_response_start/end nulos'],\n    aliases: [\n      'responseexecute', 'response execute', 'execute', 'execute_action', 'execute action',\n      'tool_execute_action', 'tool_execute_action.json', 'responseexecute.json', 'ResponseExecute.json'\n    ]\n  },\n\n  // Se mantiene por compatibilidad/consulta explícita (aunque en tu versión puede estar integrado en ResponseExecute)\n  Metrics: {\n    canonical: 'Metrics',\n    purpose: 'Consolida timestamps y calcula TTA/MTTR + estado final (en algunas versiones está integrado en ResponseExecute).',\n    inputs: ['ts_ingest', 'ts_analysis_*', 'ts_hitl_*', 'ts_response_*'],\n    outputs: ['tta_sec', 'mttr_sec', 'fr_metrics final'],\n    nodes: ['Cálculo', 'UPSERT dbo.fr_metrics'],\n    writes: ['dbo.fr_metrics (UPSERT)'],\n    common_failures: ['diferencia de tipos datetime', 'valores nulos', 'mezclar métricas por-run con por-evento'],\n    aliases: ['metrics', 'metrica', 'metricas', 'métricas', 'fr_metrics', 'tool_metrics', 'metrics.json']\n  },\n\n  // ✅ nuevo: entrypoint real del Router\n  run_soc_full: {\n    canonical: 'run_soc_full',\n    purpose: 'Ejecuta el pipeline completo SOC: Monitoring → Analysis → Response → (HITL si aplica) → ResponseExecute.',\n    inputs: ['evento o event_id', 'flags/políticas (opcional)', 'contexto (opcional)'],\n    outputs: ['estado final', 'resúmenes por etapa', 'evidencia', 'métricas (si aplica)'],\n    nodes: ['Call Monitoring', 'Call Analysis', 'Call Response', 'Call HITL (condicional)', 'Call ResponseExecute'],\n    writes: ['dbo.* (según etapas llamadas)'],\n    common_failures: ['contexto incompleto entre tools', 'orden/timestamps incompletos', 'errores no propagados'],\n    aliases: ['tool_run_soc_full', 'tool:run_soc_full', 'tool_run_soc_full.json', 'run soc full', 'soc full']\n  },\n\n  // ✅ nuevo: tool/workflow de acción\n  'Block-Unblock IP +Port': {\n    canonical: 'Block-Unblock IP +Port',\n    purpose: 'Bloquea o desbloquea una IP y/o puerto en el control correspondiente.',\n    inputs: ['ip', 'port (opcional)', 'action=block|unblock', 'reason (opcional)'],\n    outputs: ['status', 'details', 'evidence (si aplica)'],\n    nodes: ['Validación input', 'Ejecución acción', 'Respuesta/registro'],\n    writes: ['N/A (acción externa; si logueas, depende de tu implementación)'],\n    common_failures: ['ip/port no parseados', 'action inválida', 'endpoint/credenciales', 'timeouts'],\n    aliases: ['tool:Block-Unblock', 'tool_block_unblock', 'block unblock', 'Block-Unblock IP +Port.json']\n  },\n\n  // ✅ nuevo: tool/workflow de acción\n  'Register/Unregister Suspicious IP': {\n    canonical: 'Register/Unregister Suspicious IP',\n    purpose: 'Registra o desregistra una IP como sospechosa (IOC/denylist/allowlist según implementación).',\n    inputs: ['ip', 'action=register|unregister', 'reason (opcional)'],\n    outputs: ['status', 'details'],\n    nodes: ['Validación input', 'Ejecución acción', 'Respuesta/registro'],\n    writes: ['N/A (acción externa; si logueas, depende de tu implementación)'],\n    common_failures: ['ip inválida', 'action inválida', 'estado inconsistente (ya registrado)', 'endpoint/credenciales'],\n    aliases: ['tool_register_unregister', 'register unregister', 'Register_Unregister Suspicious IP.json']\n  },\n\n  // ✅ nuevo: tool de salida\n  Summarizer: {\n    canonical: 'Summarizer',\n    purpose: 'Resume resultados del pipeline (orientado a humano) para reporte/chat.',\n    inputs: ['resultado/objeto de ejecución', 'texto libre (opcional)'],\n    outputs: ['summary', 'bullets/insights'],\n    nodes: ['Transformación', 'Formato final'],\n    writes: ['N/A'],\n    common_failures: ['input llega vacío', 'objeto demasiado grande sin recorte', 'campos esperados no presentes'],\n    aliases: ['tool_summarizer', 'summarizer', 'Summarizer.json']\n  },\n\n  'SOC Inspector Router': {\n    canonical: 'SOC Inspector Router',\n    purpose: 'Agente de soporte: responde preguntas (tools/workflows/errores) y enruta solicitudes; ejecuta mitigación solo si se solicita explícitamente.',\n    inputs: ['chatInput', 'parsed_event (opcional)', 'mode INSPECT/SOC'],\n    outputs: ['respuesta + llamadas a tools (si aplica)'],\n    nodes: ['Chat Trigger', 'Detect input + parse JSON', 'Inspector Agent', 'Tool workflows'],\n    writes: ['N/A (solo lectura, salvo tools invocados)'],\n    common_failures: ['nombres parciales no mapeados', 'tools no conectados', 'no se pasa input correcto al tool'],\n    aliases: [\n      'soc inspector router', 'inspector router', 'inspector', 'router', 'soc inspector',\n      'tool_inspector', 'soc_inspector_router', 'soc inspector router.json'\n    ]\n  }\n};\n\n// Build available list (sin duplicados)\nconst AVAILABLE = Array.from(new Set(Object.keys(DB).map(k => DB[k].canonical)));\n\n// --- 3) Matching helpers ---\nfunction levenshtein(a, b) {\n  a = a || ''; b = b || '';\n  const m = a.length, n = b.length;\n  if (m === 0) return n;\n  if (n === 0) return m;\n  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));\n  for (let i = 0; i <= m; i++) dp[i][0] = i;\n  for (let j = 0; j <= n; j++) dp[0][j] = j;\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      dp[i][j] = Math.min(\n        dp[i - 1][j] + 1,\n        dp[i][j - 1] + 1,\n        dp[i - 1][j - 1] + cost\n      );\n    }\n  }\n  return dp[m][n];\n}\n\nfunction scoreCandidate(cand, target) {\n  cand = normalizeText(cand);\n  target = normalizeText(target);\n  if (!cand || !target) return 9999;\n  if (cand === target) return 0;\n  if (target.includes(cand) || cand.includes(target)) return 1;\n  return levenshtein(cand, target);\n}\n\nfunction findBestMatch(cand) {\n  const c = normalizeText(cand);\n\n  // 1) exact canonical\n  for (const k of Object.keys(DB)) {\n    if (normalizeText(DB[k].canonical) === c) return DB[k];\n  }\n\n  // 2) exact alias\n  for (const k of Object.keys(DB)) {\n    const aliases = DB[k].aliases || [];\n    if (aliases.some(a => normalizeText(a) === c)) return DB[k];\n  }\n\n  // 3) contains alias/canonical\n  for (const k of Object.keys(DB)) {\n    const canon = normalizeText(DB[k].canonical);\n    if (canon.includes(c) || c.includes(canon)) return DB[k];\n    const aliases = DB[k].aliases || [];\n    if (aliases.some(a => {\n      const aa = normalizeText(a);\n      return aa.includes(c) || c.includes(aa);\n    })) return DB[k];\n  }\n\n  // 4) fuzzy\n  let best = null;\n  let bestScore = 9999;\n\n  for (const k of Object.keys(DB)) {\n    let minScore = scoreCandidate(c, DB[k].canonical);\n    for (const a of (DB[k].aliases || [])) {\n      minScore = Math.min(minScore, scoreCandidate(c, a));\n    }\n    if (minScore < bestScore) {\n      bestScore = minScore;\n      best = DB[k];\n    }\n  }\n\n  if (best && bestScore <= 4) return best;\n  return null;\n}\n\nfunction buildSuggestions(cand, topN = 3) {\n  const c = normalizeText(cand);\n  const scored = Object.keys(DB).map(k => {\n    let s = scoreCandidate(c, DB[k].canonical);\n    for (const a of (DB[k].aliases || [])) s = Math.min(s, scoreCandidate(c, a));\n    return { name: DB[k].canonical, score: s };\n  });\n\n  scored.sort((a,b) => a.score - b.score);\n  return scored.slice(0, topN).map(x => x.name);\n}\n\n// --- 4) Resolve ---\nconst info = findBestMatch(candidate);\n\nif (!info) {\n  const suggestions = buildSuggestions(candidate, 3);\n  const output =\n`No pude identificar el workflow solicitado.\n• Recibí: \"${raw}\"\n• Interpreté: \"${candidate}\"\n• Disponibles: ${AVAILABLE.join(' | ')}\n• ¿Quizás quisiste decir?: ${suggestions.join(' | ')}\n\nEjemplos:\n- \"explica Monitoring\"\n- \"explica Response\"\n- \"explica run_soc_full\"\n- \"explica Block-Unblock IP +Port\"\n- \"explica SOC Inspector Router\"`;\n\n  return [{\n    json: {\n      ok: false,\n      received: raw,\n      interpreted: candidate,\n      matched: null,\n      available: AVAILABLE,\n      suggestions,\n      explanation: null,\n      output\n    }\n  }];\n}\n\n// --- 5) Produce tool-friendly output ---\nconst outputLines = [\n  `WORKFLOW: ${info.canonical}`,\n  `- propósito: ${info.purpose}`,\n  `- inputs clave: ${info.inputs.join(', ')}`,\n  `- outputs clave: ${info.outputs.join(', ')}`,\n  `- nodos típicos: ${info.nodes.join(' → ')}`,\n  `- tablas / escribe: ${info.writes.join(', ')}`,\n  `- fallos comunes: ${info.common_failures.join(' | ')}`\n];\n\nreturn [{\n  json: {\n    ok: true,\n    received: raw,\n    interpreted: candidate,\n    matched: info.canonical,\n    available: AVAILABLE,\n    suggestions: [],\n    explanation: info,\n    output: outputLines.join('\\n')\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -128,
        -16
      ],
      "id": "2b188446-6f7a-45d7-9c9e-e52e399bca83",
      "name": "Explain workflow (lookup)"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -304,
        -16
      ],
      "id": "bcfca5c4-1c07-487d-a82f-81b3cb656474",
      "name": "Intro Explain workflow",
      "alwaysOutputData": true
    }
  ],
  "pinData": {},
  "connections": {
    "Intro Explain workflow": {
      "main": [
        [
          {
            "node": "Explain workflow (lookup)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "41011163-6783-45eb-b393-6d5847afef6b",
  "meta": {
    "instanceId": "5f4321b383184a4332b5d1e5cb6e70ea61441780fd28eb1fe8c95676a3e6f306"
  },
  "id": "e9zcOYlWghV8nXFi",
  "tags": []
}